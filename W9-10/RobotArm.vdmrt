class RobotArm

types
    public Angle = real inv N == N >= -0.2 and N <= 1.8; -- max angles for the arm

    -- environment events
    public Event = <SensorFailure> | <ActuatorFailure>;
    public Env_user_events = <RepositiongArm> | <SwitchingEndEffector> | <TargetAngle> | <ShutdownCommand>;

values 
    public r: real = 0.8; -- arm length
    public I: real = 2 * r * r; -- inertia

instance variables
    public env_q : real; -- angle of joint. radians
    public env_q_vel: real; -- velocity. rad/s
    public env_q_acc: real; -- acceleration. rad/s^2
    public env_motorTorque: real; -- motor torque in Nm
    public last_time: real;
    public motor_stop: bool;

    --simulation time
    public final_sim_time: real;
    
operations
    public RobotArm: () ==> RobotArm
    RobotArm() == (
        env_q := 0;
        env_q_vel := 0; 
        env_q_acc := 0; 
        env_motorTorque := 0;
        motor_stop := false;
        last_time := 0;
        final_sim_time := 0;
       
    );

    -- events
    --public AddEvent : real * Event * int ==> ()
    --AddEvent(t, e, d) == duration(0) (
    --    events := events ^ [mk_(t,e,d)];
    --);

    --public CreateEvent : () ==> ()
    --reateEvent() == (
    --    if len events > 0 then ( 
    --      let mk_(stime,event,event_data) = hd events
    --      in if stime <= time then (

    --      ) 
        --)
    --);


    -- Motor actuator
    public GetMotorTorque: real ==> ()
    GetMotorTorque(torque) == duration(0) (
        env_motorTorque := torque;
    );

    public GetCurrentMotorTorque: () ==> real
    GetCurrentMotorTorque() == duration(0) (
        return env_motorTorque;
    );

    -- Angle sensor
    public GetCurrentPosition: () ==> real
    GetCurrentPosition() == duration(0) (
        return env_q;
    );

    public SetCurrentPosition: real ==> ()
    SetCurrentPosition(pos) == duration(0) (
        env_q := pos;
    );

    -- Movement Sensor (velocity and acceleration)
    public GetVelocity: () ==> real
    GetVelocity() == (
        return env_q_vel;
    );

    public GetCurrentAcceleration: () ==> real
    GetCurrentAcceleration() == (
        return env_q_acc;
    );

    public set_sim_time: real ==> ()
    set_sim_time(t) == duration(0) (
        final_sim_time := t;
    );

    public Stop: () ==> ()
    Stop() == duration(1E8) (
        motor_stop := true;
    );

    public isFinished: () ==> ()
    isFinished() == skip;





    -- step function
    public Step: () ==> ()
    Step() == duration(0) (
            dcl t : real := time / 1E9;
            dcl delta : real := (t - last_time);

            last_time := t;
            if (motor_stop = false) then (
                env_q_acc := env_motorTorque / I; -- Assuming uniform mass distribution arm length meter. a = t / i
                env_q_vel := env_q_vel + env_q_acc * delta;
                env_q := env_q + env_q_vel * delta;
            ) else (
                env_q_vel := 0;
                env_q := env_q + env_q_vel * delta;
            );
            -- Update movement values
           
    );

thread
    periodic(1E9,0,0,0)(Step);
    --periodic(1E9, 0, 0, 0)(CreateEvent);

sync
    mutex (GetCurrentPosition);
    mutex (GetMotorTorque);

    per isFinished => (time > final_sim_time);
    

end RobotArm
